# CS230

<b>Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?</b>
<br>
<br>The Gaming Room is a company that aimed to create a game called "Draw It or Lose It" based on the 80's game show "Win, Lose, or Draw". The client already created this game to be played on Android systems, and reached out for assistance in created a web-based version of the game that could handle multiple players joining teams to guess images being rendered in real time. It was my duty to design an application that would allow users to login with unique identification, offer security for login, and then connect to other players who are playing in order to join teams and guess the rendering images with them.
<br>
<br>
<br><b>What did you do particularly well in developing this documentation?</b>
<br>
<br>When it came to creating documentation of this process, the part that I believe I did particularly well was identifying possible setbacks that The Gaming Room could face during development and keeping them aware of the issue before it showed up later on down the line. It helps to let clients know beforehand what kind of complications to expect so it does not come back later as a hindrance during release.
<br>
<br>
<br><b>What about the process of working through a design document did you find helpful when developing the code?</b>
<br>
<br> The process of working through the design document was most help with code when it came to organization. For example, creating a domain model was extremely helpful in building a blueprint of the different relationships our classes would have, and brainstorming the different aspects of the code (ex: naming conventions) before actual coding was done. Being able to see the overall map of the program made designing it feel less like a shot in the dark.
<br>
<br>
<br><b>If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?</b>
<br>
<br> If I had to choose one part of my work on these documents to revise, I would pick the evalation. I would improve it by actually finding a program that is available on all of these different operating systems, and witnessing first hand how translating to each different option can change the overall feel of the game. For example, there are many stories about how games ported to different consoles end up dropping in overall quality on a new console because of how poorly in translated in a different environment. It shows that even if the original game on its original operating system is well received, it could end being viewed negatively if it is placed on a different operating system without plenty of testing and QA.
<br>
<br>
<br><b>How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?</b>
<br>
<br> I interpreted the user's needs and implemented them into the software design by making a list of all the expectations that The Gaming Room had, and considering all of the possible routes that coudl be taken to see those needs met. It is important to consider the user's needs when designing because, ultimately, the user is the one that will be using the program. It is important to separate the thought process of a programmer from the thought process of a user since most users do not care about the codes behing their products. They just want something that works how they want it to work.
<br>
<br><b>How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?</b>
<br>
<br> I approached designing the software by using the final product as a guide. The mission is always to get the program to that point even if it means going back into a code that works technically but is still subpar on the surface. Techniques that I would use in the future to analyze and design a similar software application is to create documentation that keeps track of constraints, architecture, and other important aspects of building a program beyond simply writing code.



